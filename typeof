#!/bin/bash
#                                                                       ID
#-------------------------------------------------------------------------
#    FILE: typeof
#    TYPE: bash function
#  AUTHOR: Ivan Ilic <ivanilic1975@gmail.com>
#     WEB: https://github.com/mandober/bing-bash
# LICENSE: MIT
#    DATE: 02-Sep-2017 (last revision)
#                                                                  DETAILS
#-------------------------------------------------------------------------
#  NAME:
#       typeof - variable typing and dumping
#
#  SYNOPSIS:
#       typeof [-t] NAME ...
#
#  DESCRIPTION:
#       This utility will try to qualify the arguments, to see if they
#       hold any meaning to the shell; whether they are scalar variables
#       or arrays, aliases, function names or shell keywords, etc. It is
#       mostly ment to pretty print variables: their type, value and
#       attributes. Variable names should be passed by name only (no $).
#
#       With -t option, only the type, as a single word is returned.
#       Types returned are: unset, scalar, indexed, associative.
#       Also, types returned by bash's `type` builtin are returned as:
#       alias, keyword, function, builtin, file.
#
#  OPTIONS:
#       -t, --type
#           Return the type, as single word.
#
#  OPERANDS:
#       NAME <string>
#           A word, a name, an identifier, a token, etc.
#                                                                   OUTPUT
#-------------------------------------------------------------------------
#  STDOUT:
#       Type, value and attributes of the parameter.
#       With -t option prints type as a single word.
#
#  STDERR:
#       Error messages. Help and usage, on some errors.
#
#  ENVIRONMENT:
#       This function does not influence environment variables.
#
#  RETURN CODE:
#       0  success
#       1  failure
#       2  empty parameter
#                                                                     INFO
#-------------------------------------------------------------------------
#  DEPENDENCIES:
#       none
#
#  SEE ALSO:
#       type (builtin)
#
#  NOTES:
#       Best used when sourced. It can be executed as well, but than it
#       will run in its own, separate environment, so current shell
#       varables won't be available (unless exported).
#
#  EXAMPLES:
#       typeof BASH_VERSINFO                # dumps array BASH_VERSINFO
#       typeof -t BASH_ALIASES              # outputs: `associative'
#       typeof PATH SHELLOPTS BASHOPTS LS_COLORS
#
#=========================================================================
typeof() {

#                                                                    ABOUT
#-------------------------------------------------------------------------
 local bbapp="${FUNCNAME[0]}"
 local bbnfo="$bbapp v.0.1.11"
 local usage="USAGE: $bbapp [-t] NAME ..."

#                                                                     HELP
#-------------------------------------------------------------------------
 [[ $1 =~ ^(-u|--usage)$ ]] && { printf "%s\n" "$usage"; return 0; }
 [[ $1 =~ ^(-v|--version)$ ]] && { printf "%s\n" "$bbnfo"; return 0; }
 [[ $1 =~ ^(-h|--help)$ ]] && {
  printf "\e[7m%s\e[0m\n" "$bbnfo"
  printf "\e[1m%s\e[0m\n" "$usage"
  cat <<-EOFF
	Variable typing and dumping.

	DESCRIPTION:
	  Pass an identifier (without \$), name or word NAME to
	  check its type and dump its value and attributes.
	  With -t option, only the type, as a single word, is
	  returned. Returned types are:
	   - 'unset' - for unset variables
	   - 'associative' - for associative arrays
	   - 'indexed' - for indexed arrays
	   - 'variable' - for set varables
	   or: 'alias', 'keyword', 'function', 'builtin' or 'file'
	   as reported by the 'type' builtin.

	OPTIONS:
	   -t, --type        Return type as a single word.
	   -h, --help        Show program help.
	   -u, --usage       Show program usage.
	   -v, --version     Show program version.

	EXAMPLES:
	   $bbapp -t BASH_ALIASES
	   $bbapp BASH_VERSINFO
	   $bbapp PATH SHELLOPTS BASHOPTS LS_COLORS
	EOFF
	return 0
 }

#                                                                      SET
#-------------------------------------------------------------------------
 shopt -s extglob         # Enable extended regular expressions
 shopt -s extquote        # Enables $'' and $"" quoting
 shopt -u nocasematch     # regexp case-sensitivity
 set -o noglob            # Disable globbing (set -f).
 trap "set +o noglob" RETURN ERR SIGHUP SIGINT SIGTERM


#                                                                  OPTIONS
#=========================================================================
 local bbIn=""       # input param
 local bbType=0      # Type flag: 0=extensive 1=single word output

 while (( $# > 0 )); do
  case $1 in

    -t|--type) bbType=1; shift;;

    --) shift; bbIn+="$@"; set --;;

    -*)
        # test getopt version
        getopt -T
        (($? != 4)) && {
          cat <<-EOFF >&2
					Your version of getopt cannot be used to normalize the suplied
					options. Please try again, but supply normalized options: without
					compounded short options and/or abbreviated long options.
					EOFF
          return 7
        }

        local bbGetopt=$(getopt -quo -v:t -l verbose:,type -- "$@")
        # echo "\"$bbGetopt\""
        bbGetopt="${bbGetopt# }"
        bbGetopt="${bbGetopt// -- / }"
        bbGetopt="${bbGetopt/% --/}"
        # echo "\"$bbGetopt\""
        eval set -- "$bbGetopt"
    ;;

    *) bbIn+="$1 "; shift;;
  esac
 done

 # defaults
 bbIn="${bbIn% }"

 # return operands to $@
 eval set -- "$bbIn"
 bbIn=""

 # default format for printf
 bbDim=" \e[2m%s\e[0m %s\n"



#                                                               START LOOP
#=========================================================================
# start the operanads loop
for bbIn; do

#                                                             TYPE BUILTIN
#=========================================================================
# First, check what bash's builtin `type` says. It could qualify NAME as:
# 1) keyword, 2) builtin, 3) alias, 4) function, 5) file.
local bbDeclare="$(type -t "$bbIn" 2>/dev/null)"

if [[ -n "$bbDeclare" ]]; then
    if (( bbType == 1 ))
    then
      # if `-t or --type` is used, print the findings as a single word:
      # 1) keyword, 2) builtin, 3) alias, 4) function, 5) file.
      printf "%s\n" "$bbDeclare"
    else
      # oterwise, print more verbose, and styled, results
      printf "$bbDim" "Name:" "$bbIn"
      printf "$bbDim" "Type:" "$bbDeclare"

      # In case it's a function, get the path used to source it -
      # that can be done by turning on bash's extended_debug mode.
      if [[ $bbDeclare == "function" ]]; then
        shopt -s extdebug
        local fPath="$(declare -F "$bbIn")"
        fPath=( $fPath )
        printf "$bbDim" "From:" "${fPath[2]} (line: ${fPath[1]})"
        shopt -u extdebug
      fi

    fi

else
  #                                                              UNSET VAR
  #=======================================================================
  # In order to assume the NAME is a variable (whether set or not),
  # first check if NAME is a valid shell identifier. If `set -o nounset'
  # is not enabled, all non-set variables are in fact treated as undefined
  # variables when referenced - variables with null value. Of course, they
  # are not in symbols table, so check there to identify them.
  # Return `unset' if they are not in in symbols table.

  # Assign `decalare -p NAME' to bbDeclare,
  # If assignment is empty then NAME is unset/nothing.
  if ! bbDeclare="$(declare -p "$bbIn" 2>/dev/null)"; then
    if (( bbType == 1 )); then
      printf "%s\n" "unset"
    else
      printf " \e[2m%s\e[0m %s\n" "Name:" "$bbIn"
      printf " \e[2m%s\e[0m %s\n" "Type:" "unset"
    fi
  fi

fi

#                                                                VARIABLES
#=========================================================================
# At this point NAME is set (but might be null) variable:
# whether scalar or array, it is in symbols table nonetheless.
bbDeclare=( $bbDeclare )

## Scrutinize attributes. Possible attributes:
#  a) var type attributes (-aA): scalar (-) OR indexed (a) OR assoc. array (A).
#  b) letter-casing attributes (ulc): uppercase, lowercase, title-case.
#  c) other attributes (inxrt): integer, ref, export, readonly, trace.

# get nr. of terminal columns
local -i bbCols=${COLUMNS:-$(tput cols)}
((bbCols <= 1)) && bbCols=80


case ${bbDeclare[1]} in
#                                                            INDEXED ARRAY
#=========================================================================
 *a*)
  (( bbType <= 1 )) && { printf "%s\n" "indexed"; continue; }

  local bbKey bbCurr
  local -n bbArrayRef="$bbIn"
  local -i bbNum=1
  local bbMax=0

  # max chars
  for bbKey in "${!bbArrayRef[@]}"; do
    bbCurr=${#bbArrayRef[$bbKey]}
    bbMax=$(( bbCurr > bbMax ? bbCurr : bbMax ))
  done

  printf " \e[2m%s\e[0m %s\n" "Name:" "$bbIn"
  printf " \e[2m%s\e[0m " "Type:"
  printf "indexed array [%s]\n" "${#bbArrayRef[@]}"

  # title
  printf "\e[2m%s. %7s %-*s %5s\e[0m\n" \
  " no" "key " $bbMax "value" "len"

  # value
  local bbK
  for bbK in "${!bbArrayRef[@]}"; do
    printf "\e[2m%2d.\e[0m %7s: %-*s \e[2m%5s\e[0m\n" \
    "${bbNum}" "[${bbK}]" $bbMax \
    "${bbArrayRef[$bbK]}" "${#bbArrayRef[$bbK]}"
    (( ++bbNum ))
  done
  printf "\n"
 ;;&

#                                                        ASSOCIATIVE ARRAY
#=========================================================================
 *A*)
  (( bbType == 1 )) && { printf "%s\n" "associative"; continue; }

  local -n bbArrayRef="$bbIn"
  local -i bbNum=1
  local bbKey bbCurr bbMax=0 bbCurrKey bbMaxK=0

  # max chars: value and kay
  for bbKey in "${!bbArrayRef[@]}"; do
    bbCurr=${#bbArrayRef[$bbKey]}
    bbMax=$(( bbCurr > bbMax ? bbCurr : bbMax ))
    bbCurrKey=${#bbKey}
    bbMaxK=$(( bbCurrKey > bbMaxK ? bbCurrKey : bbMaxK ))
  done
  (( bbMaxK += 2 ))

  printf " \e[2m%s\e[0m %s\n" "Name:" "$bbIn"
  printf " \e[2m%s\e[0m " "Type:"
  printf "associative array %s\n" "[${#bbArrayRef[@]}]"

  # title
  printf "\e[2m%s. %*s %-*s %5s\e[0m\n" \
    " no" $bbMaxK "key " $bbMax "value" "len"

  # value
  local bbK
  for bbK in "${!bbArrayRef[@]}"; do
    printf "\e[2m%2d.\e[0m %*s: %-*s \e[2m%5s\e[0m\n" \
    "${bbNum}" $bbMaxK "[$bbK]" $bbMax \
    "${bbArrayRef[$bbK]}" "${#bbArrayRef[$bbK]}"
    (( ++bbNum ))
  done
  printf "\n"
 ;;&

#                                                                  SCALARS
#=========================================================================
# if 1. attribute was (-) than var is scalar
 -[-linuxcrt]*)
    # if --type, output single word type
    (( bbType == 1 )) && { printf "%s\n" "scalar"; continue; }

    # otherwise output name, type and value
    local bbValue="${!bbIn}"
      printf " \e[2m%s\e[0m %s\n" "Name:" "$bbIn"
    if [[ $bbValue =~ : ]]; then
      printf " \e[2m%s\e[0m %s\n" "Type:"  "scalar (colon separated values)"
      printf "\e[2m%s\e[0m\n" "Value:"
      printf "       %s\n" ${bbValue//:/$'\n'}
    else
      printf " \e[2m%s\e[0m %s\n" "Type:" "scalar"
      printf "\e[2mValue:\e[0m %s \e[2m[%s]\e[0m\n" "$bbValue" "${#bbValue}"
    fi
 ;;&

#                                                               ATTRIBUTES
#=========================================================================
# remaining attributes
 *[linuxcrt]*) printf "\e[2m%s\e[0m\n" " Attr:";;&
  *i*) printf '    %s\n' "-i (integer)"        ;;&
  *r*) printf '    %s\n' "-r (readonly)"       ;;&
  *x*) printf '    %s\n' "-x (export)"         ;;&
  *l*) printf '    %s\n' "-l (lowercasing)"    ;;&
  *c*) printf '    %s\n' "-c (capitalizing)" ;;&
  *u*) printf '    %s\n' "-u (uppercasing)"  ;;&
  *n*) printf '    %s\n' "-n (reference)"    ;;&
  *t*) printf '    %s\n' "-t (trace)"        ;;&
  *[linuxcrt]*) printf "\n";;
esac
printf "\n"

done # end list opernads

return 0
} # end function


if [[ "$0" == "$BASH_SOURCE" ]]; then
  # if this file is executed
  echo "typeof executed"
  typeof "$@"
else
  # if this file is sourced
  echo "typeof sourced"
fi

# bash completions
complete -v typeof
