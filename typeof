#!/bin/bash
#                                                                       ID
#-------------------------------------------------------------------------
#    FILE: typeof
#    TYPE: bash function
#  AUTHOR: Ivan Ilic <ivanilic1975@gmail.com>
#     WEB: https://github.com/mandober/bing-bash
# LICENSE: MIT
#    DATE: 02-Sep-2017 (last revision)
#                                                                  DETAILS
#-------------------------------------------------------------------------
#  NAME:
#       typeof - qualify input, type and dump variable.
#
#  SYNOPSIS:
#       typeof [-t] NAME
#
#  DESCRIPTION:
#       This utility will qualify the operand NAME as:
#         - scalar (scalar variable)
#         - indexed (indexed array)
#         - associative (associative array)
#         - unset (if NAME is not a set var or not a meaningful name)
#         - function
#         - file
#         - builtin
#         - alias
#         - keyword
#       It is particulary useful for pretty printing arrays: their type,
#       value and attributes. Variable names should be supplied by name
#       only (without $).
#
#  OPTIONS:
#       -t, --type
#       Return the type, as single word.
#
#  OPERAND:
#       NAME
#       A word, a name, an identifier, a token, etc.
#                                                                   OUTPUT
#-------------------------------------------------------------------------
#  STDOUT:
#       Type, value and attributes of the parameter.
#       With -t option prints type only as a single word.
#
#  STDERR:
#       Error messages, help and usage.
#
#  ENVIRONMENT:
#       XTYPEOF variable will be set in the environment; it is associative
#       array containg results of this function. It will have a "name" key
#       containg supplied NAME, "type" key that will contain the recognized
#       type; if type is 'file' or 'function', there will also be a "path"
#       key, which in might contain one or more, colon-separated paths, to
#       that particular file or function.
#
#  RETURN CODE:
#       0  success
#       1  failure
#                                                                     INFO
#-------------------------------------------------------------------------
#  NOTES:
#       Best used when sourced. It can be executed as well, but than it
#       will run in its own, separate environment, so current shell
#       varables won't be available (unless exported).
#
#  EXAMPLES:
#       typeof BASH_VERSINFO       # pretty prints the array
#       typeof -t BASH_VERSINFO    # outputs: "associative"
#
#  DEPENDENCIES:
#       none (bash only)
#
#  SEE ALSO:
#       type (bash builtin)
#
#=========================================================================
typeof() {

#                                                                    ABOUT
#-------------------------------------------------------------------------
 local bbapp="${FUNCNAME[0]}"
 local bbnfo="$bbapp v.0.1.11"
 local usage="USAGE: $bbapp [-t] NAME ..."

#                                                                     HELP
#-------------------------------------------------------------------------
 [[ $1 =~ ^(-u|--usage)$ ]] && { printf "%s\n" "$usage"; return 0; }
 [[ $1 =~ ^(-v|--version)$ ]] && { printf "%s\n" "$bbnfo"; return 0; }
 [[ $1 =~ ^(-h|--help)$ ]] && {
  printf "\e[7m%s\e[0m\n" "$bbnfo"
  printf "\e[1m%s\e[0m\n" "$usage"
  cat <<-EOFF
	Variable typing and dumping.

	DESCRIPTION:
	  Pass an identifier (without \$), name or word NAME to
	  check its type and dump its value and attributes.
	  With -t option, only the type, as a single word, is
	  returned. Returned types are:
	   - 'unset' - for unset variables
	   - 'associative' - for associative arrays
	   - 'indexed' - for indexed arrays
	   - 'variable' - for set varables
	   or: 'alias', 'keyword', 'function', 'builtin' or 'file'
	   as reported by the 'type' builtin.

	OPTIONS:
	   -t, --type        Return type as a single word.
	   -h, --help        Show program help.
	   -u, --usage       Show program usage.
	   -v, --version     Show program version.

	EXAMPLES:
	   $bbapp -t BASH_ALIASES
	   $bbapp BASH_VERSINFO
	   $bbapp PATH SHELLOPTS BASHOPTS LS_COLORS
	EOFF
	return 0
 }

#                                                                      SET
#-------------------------------------------------------------------------
 shopt -s extglob         # Enable extended regular expressions
 shopt -s extquote        # Enables $'' and $"" quoting
 shopt -u nocasematch     # regexp case-sensitivity
 set -o noglob            # Disable globbing (set -f).
 trap "set +o noglob" RETURN ERR SIGHUP SIGINT SIGTERM # Enable globbing


#                                                                  OPTIONS
#=========================================================================
 local bbIn=""       # input parameter
 local bbQuiet=0     # output verbosity: 0=verbose, 1=single word

 # parse input args
 while (($# > 0)); do
  case $1 in
    -t|--type) bbQuiet=1; shift;;
            *) bbIn="$1"; shift;;
  esac
 done

 # default format for printf
 bbDim=" \e[2m%s\e[0m %s\n"
 bbDim1="\e[2m%s\e[0m\n"


#                                                                 ALL VARS
#=========================================================================
 # If no arg supplied print all variables
 if [[ -z $bbIn ]]; then
  printf "$bbDim1" "Variables:"
  compgen -v | column -c $(tput cols)
  printf "$bbDim1" "Functions:"
  compgen -A function | column -c $(tput cols)
  return 0
 fi


#                                                             TYPE BUILTIN
#=========================================================================
# First, check arg with `type` - it can qualify a NAME as:
# 1) keyword, 2) builtin, 3) alias, 4) function, 5) file.
local bbDeclare="$(type -t "$bbIn" 2>/dev/null)"

if [[ -n "$bbDeclare" ]]; then
    if (( bbQuiet == 1 ))
    then
      # if `-t or --type` is used, print the findings as a single word:
      # 1) keyword, 2) builtin, 3) alias, 4) function, 5) file.
      printf "%s\n" "$bbDeclare"
    else
      # oterwise, print more verbose, and styled, results
      printf "$bbDim" "Name:" "$bbIn"
      printf "$bbDim" "Type:" "$bbDeclare"

      #                                                   FUNCTION
      #-----------------------------------------------------------
      # In case it's a function, get the path used to source it -
      # that can be done by turning on bash's extended_debug mode.
      if [[ $bbDeclare == "function" ]]; then
        shopt -s extdebug
        local fPath="$(declare -F "$bbIn")"
        fPath=( $fPath )
        printf "$bbDim" "From:" "${fPath[2]} (line: ${fPath[1]})"
        shopt -u extdebug
      fi

      #                                                       FILE
      #-----------------------------------------------------------
      # In case it's a file, get its path
      if [[ $bbDeclare == "file" ]]; then
        local fPath="$(which -a "$bbIn")"
        fPath=${fPath//$'\n'/:}
        printf "$bbDim" "Path:" "$fPath"
        declare -Ag XTYPEOF=( [name]="$bbIn" [type]="$bbDeclare" [path]="$fPath" )
      fi

      #                                                    BUILTIN
      #-----------------------------------------------------------
      # If running interactively, display all builtins, hilite this one
      if [[ $bbDeclare == "builtin" ]] && [[ $- =~ i ]]; then
        printf " \e[2m%s\e[0m" "Builtins: "
        compgen -b | tr '\n' ' ' | grep -E "\b$bbIn\b"
      fi

    fi

else
  #                                                              UNSET VAR
  #=======================================================================
  # In order to assume the NAME is a variable (whether set or not),
  # first check if NAME is a valid shell identifier. If `set -o nounset'
  # is not enabled, all non-set variables are in fact treated as undefined
  # variables when referenced - variables with null value. Of course, they
  # are not in symbols table, so check there to identify them.
  # Return `unset' if they are not in in symbols table.

  # Assign `decalare -p NAME' to bbDeclare,
  # If assignment is empty then NAME is unset/nothing.
  if ! bbDeclare="$(declare -p "$bbIn" 2>/dev/null)"; then
    if (( bbQuiet == 1 )); then
      printf "%s\n" "unset"
    else
      printf " \e[2m%s\e[0m %s\n" "Name:" "$bbIn"
      printf " \e[2m%s\e[0m %s\n" "Type:" "unset"
    fi
  fi

fi

#                                                                VARIABLES
#=========================================================================
# At this point NAME is set (but might be null) variable:
# whether scalar or array, it is in symbols table nonetheless.
bbDeclare=( $bbDeclare )

## Scrutinize attributes. Possible attributes:
#  a) var type attributes (-aA): scalar (-) OR indexed (a) OR assoc. array (A).
#  b) letter-casing attributes (ulc): uppercase, lowercase, title-case.
#  c) other attributes (inxrt): integer, ref, export, readonly, trace.

# get nr. of terminal columns
local -i bbCols=${COLUMNS:-$(tput cols)}
((bbCols <= 1)) && bbCols=80


case ${bbDeclare[1]} in
#                                                            INDEXED ARRAY
#=========================================================================
 *a*)
  (( bbQuiet <= 1 )) && { printf "%s\n" "indexed"; continue; }

  local bbKey bbCurr
  local -n bbArrayRef="$bbIn"
  local -i bbNum=1
  local bbMax=0

  # max chars
  for bbKey in "${!bbArrayRef[@]}"; do
    bbCurr=${#bbArrayRef[$bbKey]}
    bbMax=$(( bbCurr > bbMax ? bbCurr : bbMax ))
  done

  printf " \e[2m%s\e[0m %s\n" "Name:" "$bbIn"
  printf " \e[2m%s\e[0m " "Type:"
  printf "indexed array [%s]\n" "${#bbArrayRef[@]}"

  # title
  printf "\e[2m%s. %7s %-*s %5s\e[0m\n" \
  " no" "key " $bbMax "value" "len"

  # value
  local bbK
  for bbK in "${!bbArrayRef[@]}"; do
    printf "\e[2m%2d.\e[0m %7s: %-*s \e[2m%5s\e[0m\n" \
    "${bbNum}" "[${bbK}]" $bbMax \
    "${bbArrayRef[$bbK]}" "${#bbArrayRef[$bbK]}"
    (( ++bbNum ))
  done
  printf "\n"
 ;;&

#                                                        ASSOCIATIVE ARRAY
#=========================================================================
 *A*)
  (( bbQuiet == 1 )) && { printf "%s\n" "associative"; continue; }

  local -n bbArrayRef="$bbIn"
  local -i bbNum=1
  local bbKey bbCurr bbMax=0 bbCurrKey bbMaxK=0

  # max chars: value and kay
  for bbKey in "${!bbArrayRef[@]}"; do
    bbCurr=${#bbArrayRef[$bbKey]}
    bbMax=$(( bbCurr > bbMax ? bbCurr : bbMax ))
    bbCurrKey=${#bbKey}
    bbMaxK=$(( bbCurrKey > bbMaxK ? bbCurrKey : bbMaxK ))
  done
  (( bbMaxK += 2 ))

  printf " \e[2m%s\e[0m %s\n" "Name:" "$bbIn"
  printf " \e[2m%s\e[0m " "Type:"
  printf "associative array %s\n" "[${#bbArrayRef[@]}]"

  # title
  printf "\e[2m%s. %*s %-*s %5s\e[0m\n" \
    " no" $bbMaxK "key " $bbMax "value" "len"

  # value
  local bbK
  for bbK in "${!bbArrayRef[@]}"; do
    printf "\e[2m%2d.\e[0m %*s: %-*s \e[2m%5s\e[0m\n" \
    "${bbNum}" $bbMaxK "[$bbK]" $bbMax \
    "${bbArrayRef[$bbK]}" "${#bbArrayRef[$bbK]}"
    (( ++bbNum ))
  done
  printf "\n"
 ;;&

#                                                                  SCALARS
#=========================================================================
# if 1. attribute was (-) than var is scalar
 -[-linuxcrt]*)
    # if --type, output single word type
    (( bbQuiet == 1 )) && { printf "%s\n" "scalar"; continue; }

    # otherwise output name, type and value
    local bbValue="${!bbIn}"
      printf " \e[2m%s\e[0m %s\n" "Name:" "$bbIn"
    if [[ $bbValue =~ : ]]; then
      printf " \e[2m%s\e[0m %s\n" "Type:"  "scalar (colon separated values)"
      printf "\e[2m%s\e[0m\n" "Value:"
      printf "       %s\n" ${bbValue//:/$'\n'}
    else
      printf " \e[2m%s\e[0m %s\n" "Type:" "scalar"
      printf "\e[2mValue:\e[0m %s \e[2m[%s]\e[0m\n" "$bbValue" "${#bbValue}"
    fi
 ;;&

#                                                               ATTRIBUTES
#=========================================================================
# remaining attributes
 *[linuxcrt]*) printf "\e[2m%s\e[0m\n" " Attr:";;&
  *i*) printf '    %s\n' "-i (integer)"        ;;&
  *r*) printf '    %s\n' "-r (readonly)"       ;;&
  *x*) printf '    %s\n' "-x (export)"         ;;&
  *l*) printf '    %s\n' "-l (lowercasing)"    ;;&
  *c*) printf '    %s\n' "-c (capitalizing)" ;;&
  *u*) printf '    %s\n' "-u (uppercasing)"  ;;&
  *n*) printf '    %s\n' "-n (reference)"    ;;&
  *t*) printf '    %s\n' "-t (trace)"        ;;&
  *[linuxcrt]*) printf "\n";;
esac
printf "\n"

# done # end opernads loop

return 0
} # end function


if [[ "$0" == "$BASH_SOURCE" ]]; then
  # if this file is executed
  echo "typeof executed"
  typeof "$@"
else
  # if this file is sourced
  echo "typeof sourced"
  # alias
  alias t=typeof
fi

# bash completions: complete with variable names (-v)
complete -v typeof